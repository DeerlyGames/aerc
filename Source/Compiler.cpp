#include "Compiler.h"

#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>

std::string ReplaceString(const std::string& str, const std::string& _before, const std::string& _after)
{
	std::size_t pos = 0;
	std::string retString = str;
	while ((pos = retString.find(_before.c_str(), pos)) != std::string::npos) {
		retString.replace(pos, _before.length(), _after.c_str());
		pos += _after.length();
	}
	return std::string(retString.c_str());	
}

std::size_t FindLastString(const std::string& str, char _c)
{
	size_t len = str.length();
    for (size_t i = len - 1; i < len; --i){
		if (str[i] == _c)
			return i;
	}	
}

Compiler::~Compiler()
{
//	Flush();
}

void Compiler::Add( const char* _file )
{
	std::ifstream in( _file, std::ios::binary );

	if( !in ||
		!in.good() )
		throw (std::string(_file)+": not found !").c_str();

	in.seekg( 0, std::ios::end );
	int length = in.tellg();
	in.seekg( 0, std::ios::beg );

	if( !length )
		return;

	// Use filename retrieval
	std::string fileName = _file;
	fileName = ReplaceString(fileName, "\\", "/");
	fileName = fileName.substr(FindLastString(fileName,'/')+1, fileName.length());

	index << "// " << fileName << std::endl
		<< "\t{ " << Hash(fileName.c_str()) << ", " << offset << ", " << length << " },"
		<< std::endl;

	if( data.tellp() > 0 )
		data << "," << std::endl;

	data << "// " << fileName << std::endl;

	for( int column = 0, c = 0; ;
		column += 6, ++offset )
	{
		c = in.get();

		if( in.eof() )
			break;

		if( column )
			data << ", ";

		if( column > 70 )
		{
			data << std::endl;
			column = 0;
		}

		data << "0x" << std::hex << c;
	}
}

void Compiler::Flush()
{
	std::string className = fileName;
	className = ReplaceString(className, "\\", "/");
	className = className.substr(FindLastString(className,'/')+1, className.length());

	if( data.tellp() <= 0 )
		return;
	{ // header file
		std::ofstream out( (fileName+".h").c_str() );

		if (!out)
			throw "Cannot write to output file.";

		out <<
			"/////////////////////////////////////////////\n\
 // Abstraction Engine Resource File \n\
 //	Version: v0.0.4 \n\
 // This is autogenerated, Changes are lost! \n\
 /////////////////////////////////////////////\n\
\n\
#ifndef " << className << "_h\n\
#define " << className << "_h\n\
\n\
\n\
#include \"Abstraction.h\"\n\
#include <istream>\n\
#include <string>\n\
\n\
/**\n\
 * Manage resources\n\
 */\n\
class " << className << "\n\
{\n\
	public:\n\
		" << className << "( const std::string & );\n\
		virtual ~" << className << "();\n\
\n\
		inline bool good() const { return in ? true : false; }\n\
		inline std::istream *stream() const { return in; }\n\
		static AE::IStream * Get( const std::string & );\n\
//		static std::string getString( const std::string & );\n\
\n\
	private:\n\
		std::istream *in;\n\
\n\
		static int hash( const char * );\n\
};\n\
\n\
#endif" << std::endl;
	}

	{ // source file
		std::ofstream out( (fileName+".cpp").c_str() );

		if (!out)
			throw "Cannot write to output file.";
		
		out <<
"/////////////////////////////////////////////\n\
 // Abstraction Engine Resource File \n\
 //	Version: v0.0.4 \n\
 // This is autogenerated, Changes are lost! \n\
 /////////////////////////////////////////////\n\
\n\
#include \"" << className << ".h\"\n\
\n\
#include <istream>\n\
#include <fstream>\n\
#include <sstream>\n\
#include <string>\n\
\n\
using namespace std;\n\
\n\
static const struct RESOURCE_INDEX\n\
{\n\
	const int hash;\n\
	const int offset;\n\
	const int length;\n\
} resources_index[] = {\n\
" << index.str() << "\
	{ 0, 0, 0 }\n\
};\n\
\n\
// Not entirely sure if unsigned char or char\n\
static unsigned char resources_data[] = {\n\
	" << data.str() << "\n\
};\n\
\n\
/**\n\
 * Initialize object\n\
 *\n\
 * @param className - path and file name\n\
 */\n\
" << className << "::" << className << "( const string &className )// :\n\
//	in( Get( className ) )\n\
{\n\
}\n\
\n\
/**\n\
 * Clean up\n\
 */\n\
" << className << "::~" << className << "()\n\
{\n\
//	if( !in )\n\
//		return;\n\
//\n\
//	delete in;\n\
}\n\
\n\
/**\n\
 * Return input stream for a given file\n\
 *\n\
 * @param className - path and file name\n\
 */\n\
AE::IStream* "<< className << "::Get( const string &className )\n\
{\n\
	int h = hash( className.c_str() );\n\
//	int h = hash( className.substr( 1 ).c_str() );\n\
	const struct RESOURCE_INDEX *r = resources_index;\n\
\n\
	for( ; r->hash && r->hash != h; ++r );\n\
\n\
	if( !r->hash )	return NULL;\n\
\n\
	// Must reinterpret_cast because of clang. I am pretty sure things are clamped.\n\
	string s( reinterpret_cast< const char* >(&resources_data[r->offset]), r->length );\n\
\n\
	return new AE::IStringStream( AE::String(s) );\n\
}\n\
\n\
/**\n\
 * Return contents as a string of the given file\n\
 *\n\
 * @param className - path and file name\n\
 */\n\
//string " << className << "::getString( const string &className  )\n\
//{\n\
//	" << className << " r( className );\n\
//\n\
//	if( !r.good() )\n\
//		return \"\";\n\
//\n\
//	istream &in = *r.stream();\n\
//\n\
//	in.seekg( 0, ios::end );\n\
//	int length = in.tellg();\n\
//	in.seekg( 0, ios::beg );\n\
//\n\
//	char buffer[4096];\n\
//\n\
//	in.read( buffer, length );\n\
//	buffer[length] = 0;\n\
//\n\
//	return string( buffer );\n\
//}\n\
\n\
/**\n\
 * Calculate hash value\n\
 *\n\
 * @param s - some string\n\
 */\n\
int " << className << "::hash( const char *s )\n\
{\n\
	int h;\n\
\n\
	for( h = *(s++) % " << HashMax << "; *s; ++s )\n\
		h = (h*128+*s) % " << HashMax << ";\n\
\n\
	return h;\n\
}" << std::endl;
	}

	data.clear();
	index.clear();
	offset = 0;
}


int Compiler::Hash( const char *_s ) const
{
	int h;

	for( h = *(_s++) % HashMax; *_s; ++_s )
		h = (h*128+*_s) % HashMax;

	return h;
}