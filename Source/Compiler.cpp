#include "Compiler.h"

#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>

std::string ReplaceString(const std::string& str, const std::string& _before, const std::string& _after)
{
	std::size_t pos = 0;
	std::string retString = str;
	while ((pos = retString.find(_before.c_str(), pos)) != std::string::npos) {
		retString.replace(pos, _before.length(), _after.c_str());
		pos += _after.length();
	}
	return std::string(retString.c_str());	
}

Compiler::~Compiler()
{
	Flush();
}

bool Compiler::Add( const char* _file )
{
	std::ifstream in( _file, std::ios::binary );
	//|| !in.good()
	if( !in ){
		std::cout<< (std::string(_file)+": not found !") << std::endl;
		return false;
	}

	in.seekg( 0, std::ios::end );
	std::streampos length = in.tellg();
	in.seekg( 0, std::ios::beg );

	if( !length ){
		std::cout<< (std::string(_file)+": is empty you probably. Empty files give table problems.") << std::endl;
		return false;
	}

	index << "// " << _file << std::endl
		<< "\t{ " << Hash(_file) << ", " << offset << ", " << length << " },"
		<< std::endl;

	if( data.tellp() > 0 )
		data << "," << std::endl;

	data << "// " << _file << std::endl;

	for( int column = 0, c = 0; ;
		column += 6, ++offset )
	{
		c = in.get();

		if( in.eof() )
			break;

		if( column )
			data << ", ";

		if( column > 70 )
		{
			data << std::endl;
			column = 0;
		}

		data << "0x" << std::hex << c;
	}

	return true;
}

void Compiler::Flush()
{
	std::string outputNameSpace = fileName;
//	outputNameSpace = ReplaceString(outputNameSpace, "\\", "/");

	if( data.tellp() <= 0 )
		return;
	{ // header file
		std::ofstream out( (fileName+".h").c_str() );

		if (!out)
			throw "Cannot write to output file.";

		out <<
"/////////////////////////////////////////////\n\
 // AERC: Resource Compiler. Version: v0.0.4  \n\
 // This is autogenerated, changes are lost! \n\
 /////////////////////////////////////////////\n\
\n\
#ifndef AERC_" << outputNameSpace << "_h\n\
#define AERC_" << outputNameSpace << "_h\n\
\n\
#ifdef __cplusplus \n\
extern \"C\" { \n\
#endif \n\
\n\
int "<< outputNameSpace <<"_Has(const char* _key); \n\
\n\
const char* "<< outputNameSpace <<"_GetText(const char* _key); \n\
\n\
#ifdef __cplusplus \n\
} \n\
#endif \n\
\n\
#endif // AERC_"<< outputNameSpace << "_h" << std::endl;
	}

	{ // source file
		std::ofstream out( (fileName+".c").c_str() );

		if (!out)
			throw "Cannot write to output file.";
		
		out <<
"/////////////////////////////////////////////\n\
 // AERC: Resource Compiler. Version: v0.0.4  \n\
 // This is autogenerated, changes are lost! \n\
 /////////////////////////////////////////////\n\
\n\
#include \"" << outputNameSpace << ".h\"\n\
\n\
#include \"Resource.h\"\n\
#include <string.h>\n\
#include <stdlib.h>\n\
#include <stdio.h>\n\
\n\
static const struct RESOURCE_INDEX\n\
{\n\
	const int hash;\n\
	const int offset;\n\
	const int length;\n\
} resources_index[] = {\n\
" << index.str() << "\
	{ 0, 0, 0 }\n\
};\n\
\n\
// Not entirely sure if unsigned char or char\n\
static unsigned char resources_data[] = {\n\
	" << data.str() << "\n\
};\n\
\n\
static int hash( const char *s ){\n\
	int h;\n\
	for( h = *(s++) % " << HashMax << "; *s; ++s )\n\
		h = (h*128+*s) % " << HashMax << ";\n\
	return h;\n\
}\n\
\n\
int "<<outputNameSpace<<"_Has(const char* _key){\n\
	const struct RESOURCE_INDEX *r = resources_index;\n\
	const int h = hash( _key );\n\
\n\
	for( ; r->hash && r->hash != h; ++r );\n\
\n\
	if( !r->hash )	return 0;\n\
	return 1;	\n\
}\n\
\n\
const char* "<<outputNameSpace<<"_GetText(const char* _key){\n\
	if(!"<<outputNameSpace<<"_Has) return NULL; \n\
	const struct RESOURCE_INDEX *r = resources_index; \n\
	const int len = r->length;\n\
	char* buffer = (char*)malloc(sizeof(char)*len+1);\n\
	strncpy ( buffer, &resources_data[r->offset], len );\n\
	buffer[len]=\'\\0\';\n\
	const char* res = strdup(buffer);\n\
	free(buffer);\n\
	return res;\n\
}" << std::endl;
	}

	data.clear();
	index.clear();
	offset = 0;
}


int Compiler::Hash( const char *_s ) const
{
	int h;

	for( h = *(_s++) % HashMax; *_s; ++_s )
		h = (h*128+*_s) % HashMax;

	return h;
}